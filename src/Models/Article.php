<?php

namespace Mezian\Zaina\Models;

use Carbon\Carbon;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Str;
use Mezian\Zaina\Traits\SluggableTrait;
use Illuminate\Database\Eloquent\Model;
use Mezian\Zaina\Traits\TaggableTrait;

class Article extends Model
{
  use SluggableTrait, TaggableTrait, SoftDeletes;
  use \Staudenmeir\EloquentEagerLimit\HasEagerLimit;

  protected $dates = [ 'deleted_at', 'date_to_publish' ];

  protected $with    = [ 'tags', 'author', 'category', 'metas', 'publisher' ];
  protected $appends = [ 'url' ];

  protected $fillable = [
    'title',
    'image',
    'content',
    'category_id',
    'date_to_publish',
    'is_article_ticker',
    'is_main_article',
    'is_special_article',
    'is_particular_article',
    'is_shown_in_template',
    'is_share_to_facebook',
    'is_share_to_twitter',
    'summary',
    'source',
    'highlight_title',
    'image_description',
    'author_id',
    'use_watermark',
    'is_draft',
    'is_disabled',
  ];

  protected $casts = [
    'is_main_article' => 'boolean',
  ];

  protected static function boot()
  {
    parent::boot(); // TODO: Change the autogenerated stub

    self::creating( function ( $article ) {
      $article->attributes['title']   = $article->attributes['title'] == null ? 'draft' : $article->attributes['title'];
      $article->attributes['content'] = $article->attributes['content'] == null ? 'draft' : $article->attributes['content'];
      $article->attributes['image']   = $article->attributes['image'] == '' ? 'draft' : $article->attributes['image'];
      $article->created_by            = Auth::user()->id;
      $article->modified_by           = Auth::user()->id;
      $article->slug                  = Str::limit( $article->slug, 37 );

    } );

    self::created( function ( $article ) {
      if ( is_null( $article->date_to_publish ) || $article->date_to_publish === null )
      {
        $article->date_to_publish = $article->created_at;
      }
    } );

    self::created( function ( $article ) {
      Meta::data( $article, request()->all() );

    } );

    self::updated( function ( $article ) {
      Meta::data( $article, request()->all() );
      $article->modified_by = Auth::user()->id;
    } );

//        self::retrieved(function($article) {
//            $article->author = [$article->author];
//        });
  }

  /**
   * Return the sluggable configuration array for this model.
   *
   * @return array
   */
  public function sluggable()
  {
    return [
      'slug' => [
        'source' => 'title',
      ],
    ];
  }

  public function getUrlAttribute()
  {
    return route( 'article', [ 'slug' => $this->id . '-' . $this->slug ] );
  }

  public function getMorphClass()
  {
    return 'Article';
  }

  public function metas()
  {
    return $this->morphOne( Meta::class, 'metaable' );

  }

  public function tags()
  {
    return $this->morphToMany( Tag::class, 'taggable' )
                ->where( 'is_disabled', 0 )
                ->select( [ 'id', 'name', 'slug' ] );
  }

  public function category()
  {
    return $this->belongsTo( Category::class );
  }

  public function publisher()
  {
    return $this->belongsTo( User::class, 'created_by' )
                ->select( [ 'id', 'display_name' ] );
  }

  public function author()
  {
    return $this->BelongsTo( Author::class );
  }

  public function setDateToPublishAttribute( $value )
  {
    $date                                = $this->parseDate( $value );
    $this->attributes['date_to_publish'] = $date;

  }

  public function scopeOrder( $query )
  {
    return $query->orderBy( 'id', 'DESC' );
  }

  public function scopeLive( $query )
  {
    return $query->where( 'is_draft', 0 )
                 ->where( 'is_disabled', 0 )
                 ->where( 'is_archived', 0 )
                 ->where( 'date_to_publish', '<=', now() );
  }

  public function scopeSearch( $q, $data )
  {
    if ( ! is_null( $data['title'] ) || $data['title'] != '' )
    {
      $q->where( 'title', 'LIKE', '%' . $data['title'] . '%' );
    }

    if ( ! is_null( $data['category_id'] ) || $data['category_id'] != '' )
    {
      $q->where( 'category_id', $data['category_id'] );
    }

    if ( ! is_null( $data['from_date'] ) || $data['from_date'] != '' )
    {
      $q->where( 'created_at', '>=', $this->parseDate( $data['from_date'] ) );
    }

    if ( ! is_null( $data['to_date'] ) || $data['to_date'] != '' )
    {
      $q->where( 'created_at', '<=', $this->parseDate( $data['to_date'] ) );
    }

    return $q;

  }

  public function parseDate( $value )
  {
    $date = new Carbon( substr( $value, 0, 24 ) );

    return Carbon::createFromFormat( 'Y-m-d H:i:s', $date )->format( 'Y-m-d H:i:s' );
  }

  public function increaseView()
  {
    $this->timestamps = false;
    get_class( $this )::where( 'id', $this->id )->update( [ 'no_of_views' => $this->no_of_views + 1 ] );
    $this->timestamps = true;

    return $this;
  }

}
